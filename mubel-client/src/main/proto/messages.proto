syntax = "proto3";

option java_multiple_files = true;
option java_package = "io.mubel.api.grpc";
option java_outer_classname = "EventsProto";
package events;

/*
An "event" is a data record expressing an occurrence and its context.
 */
message EventDataInput {
  string id = 1; // Id of the event - REQUIRED
  string streamId = 2; // The id of the event stream / entity - REQUIRED
  uint32 version = 3; // version of the event in the event stream - REQUIRED
  string source = 4; // The producer if the event
  string type = 5; // Type of event - REQUIRED
  bytes data = 7; // event data
}

/*
An "event" is a data record expressing an occurrence and its context.
Events will contain two types of information: the Event Data representing the Occurrence and Context metadata providing contextual information about the Occurrence.
 */
message EventData {
  string id = 1; // Id of the event - REQUIRED
  string streamId = 2; // The id of the event stream / entity - REQUIRED
  uint32 version = 3; // version of the event in the event stream - REQUIRED
  string source = 4; // The producer if the event
  string type = 5; // Type of event - REQUIRED
  int64 createdAt = 6; // Timestamp in
  int64 sequenceNo = 7; // The unique sequence no for this event
  bytes data = 8; // event data
}

message AppendRequest {
  string esid = 1; // The name of the event store to append to
  repeated EventDataInput events = 2;
}

message GetEventsRequest {
  // required
  string esid = 1;
  // result will only contain events for this stream id if specified
  string streamId = 2;
  // only effective when stream id is specified
  uint32 fromVersion = 3;
  // only effective when stream id is specified
  uint32 toVersion = 4;
  // max size of the result list (default 999)
  uint32 size = 5;
  // return events created after the sequence no, only effective if stream id has not been specified
  int64 fromSequenceNo = 6;
}

message SubscribeRequest {
  string esid = 1;
  int64 fromSequenceNo = 2;
}

message GetEventsResponse {
  string streamId = 1;
  uint32 size = 2;
  repeated EventData events = 3;
}

enum DataFormat {
  OTHER = 0;
  PROTO = 1;
  JSON = 2;
}

message ProvisionEventStoreRequest {
  string esid = 1;
  DataFormat dataFormat = 2;
  bool waitForOpen = 3; // if true, the call will block until the event store is open
}

message DropEventStoreRequest {
  string esid = 1;
}

message DropEventStoreResponse {
  string esid = 1;
}

message EventStoreDetails {
  string esid = 1;
  string type = 2;
  DataFormat dataFormat = 3;
}

message AppendAck {
  string message = 1;
}

message ProblemDetail {
  /**
     * A URI reference that identifies the problem type
     * @format uri
     */
  string type = 1;
  /**
   * A short, human-readable summary of the problem type
   */
  string title = 2;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem
   */
  uint32 status = 3;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  string detail = 4;
}

message GetServiceInfoRequest {

}

message StorageBackendInfo {
  string name = 1;
  string type = 2;
}

message ServiceInfoResponse {
  repeated StorageBackendInfo storageBackends = 1;
  repeated EventStoreDetails eventStores = 2;
}

/**
  * A scheduled event is an event that will be published at a specific time in the future.
  * These events are not handled by the event store and will not be present in the event stores various services
  * such as subscriptions etc.
  *
  * Scheduled events are useful for triggering events at a specific time in the future, for example handling timout or triggering
  * of various business processes.
 */
message ScheduledEvent {
  // Id of the event - REQUIRED
  string id = 1;
  // REQUIRED
  string category = 2;
  // The time in milliseconds since the epoch (UTC) when the event should be published - REQUIRED
  uint64 publishTime = 3;
  // Type of event - REQUIRED
  string type = 4;
  // event data
  bytes data = 5;
}
/**
 * Cancel a scheduled event. The event will not be published.
 */
message CancelScheduledEventsRequest {
  // Ids of the events to cancel - REQUIRED
  repeated string eventId = 1;
}
/**
 * Subscribe to scheduled events. The subscriber will receive events when they are published.
 */
message ScheduledEventsSubscribeRequest {
  // the categories to subscribe to. If empty, all categories will be subscribed to
  repeated string category = 1;
}

/**
 * Contains events that have been triggered.
 */
message TriggeredEvents {
  repeated ScheduledEvent event = 1;
}