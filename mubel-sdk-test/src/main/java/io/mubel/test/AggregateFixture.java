package io.mubel.test;

import io.mubel.sdk.execution.AggregateInvocationConfig;

import java.util.List;
import java.util.function.Consumer;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;


public class AggregateFixture<T> {

    private List<Object> actualEvents;
    private final AggregateInvocationConfig<T, Object, Object> config;
    private final T state;
    private boolean commandExecuted = false;

    public AggregateFixture(AggregateInvocationConfig<T, Object, Object> config) {
        this.config = config;
        this.state = config.aggregateSupplier().get();
    }

    public AggregateFixture<T> given(Object... events) {
        return given(List.of(events));
    }

    public AggregateFixture<T> given(List<Object> events) {
        final var dispatcher = config.eventDispatcher().resolveEventHandler(state);
        for (final var event : events) {
            dispatcher.accept(event);
        }
        return this;
    }

    /**
     * Given a list of commands, execute them and apply the resulting events to the aggregate
     * Any events generated by the commands will not be stored in the fixture,
     * i.e. they will not show up in expectEvents or expectEventCount
     *
     * @param commands
     * @return
     */
    public AggregateFixture<T> givenCommands(Object... commands) {
        return givenCommands(List.of(commands));
    }

    /**
     * Given a list of commands, execute them and apply the resulting events to the aggregate
     * Any events generated by the commands will not be stored in the fixture,
     * i.e. they will not show up in expectEvents or expectEventCount
     *
     * @param commands
     * @return
     */
    public AggregateFixture<T> givenCommands(List<Object> commands) {
        final var cmdHandler = config.commandDispatcher().resolveCommandHandler(state);
        for (final var cmd : commands) {
            final var result = cmdHandler.apply(cmd);
            given(result);
        }
        return this;
    }

    /**
     * Execute a command and apply the resulting events to the aggregate
     * Any events generated by the command can be asserted on using expectEvents or expectEventCount
     *
     * @param command
     * @return
     */
    public AggregateFixture<T> when(Object command) {
        final var result = config.commandDispatcher()
                .resolveCommandHandler(state)
                .apply(command);
        given(result);
        this.actualEvents = result;
        commandExecuted = true;
        return this;
    }

    public AggregateFixture<T> expectSuccessfulHandlerExecution() {
        assertCommandHasBeenExecuted();
        return this;
    }

    /**
     * Assert that the command handler returned the expected events
     *
     * @param events
     * @return
     */
    public AggregateFixture<T> expectEvents(Object... events) {
        assertCommandHasBeenExecuted();
        assertCommandHandlerReturnValue();
        assertThat("expectEvents", actualEvents, hasItems(events));
        return this;
    }

    /**
     * Assert that the command handler did not produce any events
     *
     * @return
     */
    public AggregateFixture<T> expectNoEvents() {
        assertCommandHasBeenExecuted();
        assertCommandHandlerReturnValue();
        assertThat("expectNoEvents", actualEvents, hasSize(0));
        return this;
    }

    /**
     * Assert that the command handler produced the expected number of events
     *
     * @param count
     * @return
     */
    public AggregateFixture<T> expectEventCount(int count) {
        assertCommandHasBeenExecuted();
        assertCommandHandlerReturnValue();
        assertThat("expectEventCount", actualEvents, hasSize(count));
        return this;
    }

    /**
     * Another way to assert on the events produced by the command handler
     * Useful when you what to use other assertion methods than simple equality
     *
     * @param eventConsumer
     * @return
     */
    public AggregateFixture<T> expectEventsSatisfies(Consumer<List<?>> eventConsumer) {
        assertCommandHasBeenExecuted();
        assertCommandHandlerReturnValue();
        eventConsumer.accept(actualEvents);
        return this;
    }

    /**
     * Assert that at least one of the events produced by the command handler satisfies the given condition verified by the eventConsumer
     *
     * @param eventConsumer
     * @return
     */
    public AggregateFixture<T> expectAnyEventSatisfies(Consumer<Object> eventConsumer) {
        assertCommandHasBeenExecuted();
        assertCommandHandlerReturnValue();
        assertThat("at least one event is expected", actualEvents, hasSize(greaterThan(0)));
        AssertionError lastError = null;
        boolean success = false;
        for (final var event : actualEvents) {
            try {
                eventConsumer.accept(event);
                success = true;
                break;
            } catch (AssertionError e) {
                lastError = e;
            }
        }
        if (!success && lastError != null) {
            throw lastError;
        }
        return this;
    }

    /**
     * Assert that the aggregate state satisfies the given condition verified by the stateConsumer
     *
     * @param condition
     * @return
     */
    public AggregateFixture<T> state(Consumer<T> condition) {
        condition.accept(state);
        return this;
    }

    private void assertCommandHandlerReturnValue() {
        assertThat("Aggregate should return a non null result", actualEvents, notNullValue());
    }

    private void assertCommandHasBeenExecuted() {
        assertThat("No command has been executed", commandExecuted);
    }
}
